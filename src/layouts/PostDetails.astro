---
import Datetime from "@components/Datetime";
import Footer from "@components/Footer.astro";
import Tag from "@components/Tag.astro";
import Layout from "@layouts/Layout.astro";
import { slugifyStr } from "@utils/slugify";
import type { CollectionEntry } from "astro:content";
import Chat from "./Chat.tsx";

export interface Props {
  post: CollectionEntry<"blog">;
}

const { post } = Astro.props;

const {
  title,
  author,
  description,
  ogImage,
  canonicalURL,
  pubDatetime,
  tags,
  minutesRead,
} = post.data;

const { Content } = await post.render();
const ogUrl = new URL(ogImage ? ogImage : `${title}.png`, Astro.url.origin)
  .href;
const devMode = import.meta.env.PROD;
---

{devMode && <Chat client:only post={post.data.title} />}

<Layout
  title={title}
  author={author}
  description={description}
  ogImage={ogUrl}
  canonicalURL={canonicalURL}
  article={{
    publishedTime: pubDatetime?.toISOString(),
    authors: [author],
    tags,
    section: "Technology",
  }}
>
  <main class="w-full px-12 2xl:pl-20">
    <Datetime
      datetime={pubDatetime}
      minutesRead={minutesRead}
      size="lg"
      className="my-2 max-w-2xl"
    />
    <h1
      class="mt-4 max-w-2xl text-6xl font-semibold text-skin-accent md:text-6xl"
    >
      {title}
    </h1>
    <p class="my-4 max-w-2xl text-lg text-slate-500 md:text-xl">
      {description}
    </p>

    <div class="mt-20"></div>
    <article
      id="article"
      role="article"
      class="prose flex max-w-full justify-between [word-spacing:.08em] prose-code:font-[monospace]"
    >
      <div class="w-full lg:max-w-xl xl:max-w-2xl">
        <Content />
      </div>
      <aside
        class="relative hidden w-1/3 list-inside pl-0 text-sm text-gray-700 transition-[margin-top] lg:block"
      >
      </aside>
    </article>

    <ul class="my-8">
      {tags.map(tag => <Tag name={slugifyStr(tag)} />)}
    </ul>
  </main>

  <script define:vars={{ title }}>
    document.addEventListener("DOMContentLoaded", function () {
      const articleEl = document.getElementById("article");
      articleEl?.querySelectorAll("a").forEach(anchorEl => {
        const link = anchorEl.getAttribute("href") ?? "";
        const isOutboundLink =
          link.startsWith("http") && !link.startsWith(window.location.origin);
        const eventName = isOutboundLink ? "OutboundLink" : "InternalLink";
        anchorEl.addEventListener("click", () => {
          window.plausible(eventName, {
            props: {
              href: link,
              blog: title,
            },
          });
        });
      });
    });
  </script>
  <!-- <script is:inline type="module">
    const asideEl = document.querySelector(`aside`);
    if (asideEl) {
      const tableOfContentHeadingEl =
        document.querySelector(`#table-of-content`);
      const tableOfContentEl = document.querySelector(`#table-of-content + ul`);
      if (tableOfContentHeadingEl && tableOfContentEl) {
        asideEl.appendChild(tableOfContentHeadingEl);
        asideEl.appendChild(tableOfContentEl);
      }
    }
  </script>
  <script is:inline type="module">
    const tableOfContent = document.querySelector(`aside`);
    function setTableOfContentPosition() {
      const article = document.getElementById(`article`);
      const header = document.getElementById(`header`);
      if (!article || !header || !tableOfContent) return;

      const scrollPosition = document.documentElement.scrollTop;
      const articleDistanceToTop = article.offsetTop - header.clientHeight;
      const scrollReachedArticle = scrollPosition > articleDistanceToTop;

      const articleOffsetToTop = scrollReachedArticle
        ? scrollPosition + header.clientHeight - article.offsetTop
        : 0;

      tableOfContent.style.setProperty(
        "--table-of-content-top",
        scrollReachedArticle ? `1.5rem` : "0"
      );
      tableOfContent.style.top = `${articleOffsetToTop}px`;
    }

    setTableOfContentPosition();
    window.addEventListener("scroll", setTableOfContentPosition);

    window.addEventListener("DOMContentLoaded", () => {
      const observer = new IntersectionObserver(entries => {
        let lastEl = null;
        const tableOfContent = document.querySelector(`#table-of-content + ul`);
        const children = tableOfContent.querySelectorAll(`li a`);
        entries.forEach(entry => {
          const id = entry.target.getAttribute("id");
          const element = tableOfContent.querySelector(`li a[href="#${id}"]`);
          const heading = entry.target;

          if (!element) return;
          if (!entry.isIntersecting) return;

          // TODO: move this logic to use scroll event instead of intersection observer
          // because the intersection observer only fires when the element is visible/intersected and otherwise

          // const center = window.innerHeight / 2;
          // const headingTop = heading.getBoundingClientRect().top;
          // const headingBottom = heading.getBoundingClientRect().bottom;
          // const headingCenter = headingTop + (headingBottom - headingTop) / 2;

          // // if the intersected heading is not in the center
          // // of the screen then keep the last heading active.

          // if (headingCenter > center) return;

          children.forEach(child => {
            if (child !== element) {
              child.classList.remove("active");
            }
          });
          element.classList.add("active");
        });
      });

      // Track all sections that have an `id` applied
      document.querySelectorAll("h2,h3,h4").forEach(section => {
        observer.observe(section);
      });
    });
  </script> -->
</Layout>
