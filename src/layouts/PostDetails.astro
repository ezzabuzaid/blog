---
import Datetime from "@components/Datetime";
import Footer from "@components/Footer.astro";
import Tag from "@components/Tag.astro";
import Layout from "@layouts/Layout.astro";
import { slugifyStr } from "@utils/slugify";
import type { CollectionEntry } from "astro:content";
import Chat from "./Chat.tsx";

export interface Props {
  post: CollectionEntry<"blog">;
}

const { post } = Astro.props;

const {
  title,
  author,
  description,
  ogImage,
  canonicalURL,
  pubDatetime,
  tags,
  minutesRead,
} = post.data;

const { Content } = await post.render();
const ogUrl = new URL(ogImage ? ogImage : `${title}.png`, Astro.url.origin)
  .href;
const devMode = import.meta.env.DEV;
---

{devMode && <Chat client:only post={post.data.title} />}

<Layout
  title={title}
  author={author}
  description={description}
  ogImage={ogUrl}
  canonicalURL={canonicalURL}
  article={{
    publishedTime: pubDatetime?.toISOString(),
    authors: [author],
    tags,
    section: "Technology",
  }}
>
  <main class="w-full px-12 2xl:pl-20">
    <Datetime
      datetime={pubDatetime}
      minutesRead={minutesRead}
      size="lg"
      className="my-2 max-w-2xl"
    />
    <h1
      class="mt-4 max-w-2xl text-6xl font-semibold text-skin-accent md:text-6xl"
    >
      {title}
    </h1>
    <p class="my-4 max-w-2xl text-lg text-slate-500 md:text-xl">
      {description}
    </p>

    <div class="mt-20"></div>
    <article
      id="article"
      role="article"
      class="prose w-full max-w-full justify-between [word-spacing:.08em] prose-code:font-[monospace] xl:max-w-3xl"
    >
      <Content />
    </article>
    <!-- <article
      id="article"
      role="article"
      class="prose flex max-w-full justify-between [word-spacing:.08em] prose-code:font-[monospace]"
    >
      <div class="w-full xl:max-w-2xl">
        <Content />
      </div>
      <aside
        class="relative hidden w-1/3 list-inside pl-0 text-sm text-gray-700 transition-[margin-top] lg:block"
      >
      </aside>
    </article> -->

    <ul class="my-8">
      {tags.map(tag => <Tag name={slugifyStr(tag)} />)}
    </ul>
  </main>

  <script define:vars={{ title }}>
    document.addEventListener("DOMContentLoaded", function () {
      const articleEl = document.getElementById("article");
      articleEl?.querySelectorAll("a").forEach(anchorEl => {
        const link = anchorEl.getAttribute("href") ?? "";
        const isOutboundLink =
          link.startsWith("http") && !link.startsWith(window.location.origin);
        const eventName = isOutboundLink ? "OutboundLink" : "InternalLink";
        anchorEl.addEventListener("click", () => {
          window.plausible(eventName, {
            props: {
              href: link,
              blog: title,
            },
          });
        });
      });
    });
  </script>
  <!-- <script is:inline type="module">
    const asideEl = document.querySelector(`aside`);
    if (asideEl) {
      const tableOfContentHeadingEl =
        document.querySelector(`#table-of-content`);
      const tableOfContentEl = document.querySelector(`#table-of-content + ul`);
      if (tableOfContentHeadingEl && tableOfContentEl) {
        asideEl.appendChild(tableOfContentHeadingEl);
        asideEl.appendChild(tableOfContentEl);
      }
    }
  </script>
  <script is:inline type="module">
    const tableOfContent = document.querySelector(`aside`);
    function setTableOfContentPosition() {
      const article = document.getElementById(`article`);
      const header = document.getElementById(`header`);
      if (!article || !header || !tableOfContent) return;

      const scrollPosition = document.documentElement.scrollTop;
      const articleDistanceToTop = article.offsetTop - header.clientHeight;
      const scrollReachedArticle = scrollPosition > articleDistanceToTop;

      const articleOffsetToTop = scrollReachedArticle
        ? scrollPosition + header.clientHeight - article.offsetTop
        : 0;

      tableOfContent.style.setProperty(
        "--table-of-content-top",
        scrollReachedArticle ? `1.5rem` : "0"
      );
      tableOfContent.style.top = `${articleOffsetToTop}px`;
    }

    setTableOfContentPosition();
    window.addEventListener("scroll", setTableOfContentPosition);

    window.addEventListener("DOMContentLoaded", () => {
      const observer = new IntersectionObserver(entries => {
        let lastEl = null;
        const tableOfContent = document.querySelector(`#table-of-content + ul`);
        const children = tableOfContent.querySelectorAll(`li a`);
        entries.forEach(entry => {
          const id = entry.target.getAttribute("id");
          const element = tableOfContent.querySelector(`li a[href="#${id}"]`);
          const heading = entry.target;

          if (!element) return;
          if (!entry.isIntersecting) return;

          // TODO: move this logic to use scroll event instead of intersection observer
          // because the intersection observer only fires when the element is visible/intersected and otherwise

          // const center = window.innerHeight / 2;
          // const headingTop = heading.getBoundingClientRect().top;
          // const headingBottom = heading.getBoundingClientRect().bottom;
          // const headingCenter = headingTop + (headingBottom - headingTop) / 2;

          // // if the intersected heading is not in the center
          // // of the screen then keep the last heading active.

          // if (headingCenter > center) return;

          children.forEach(child => {
            if (child !== element) {
              child.classList.remove("active");
            }
          });
          element.classList.add("active");
        });
      });

      // Track all sections that have an `id` applied
      document.querySelectorAll("h2,h3,h4").forEach(section => {
        observer.observe(section);
      });
    });
  </script> -->
  <script>
    (() => {
      const article = document.querySelector("article");
      if (!article) {
        return;
      }

      function spanify(
        el: Element,
        ignore: (node: Element) => boolean = () => false
      ) {
        for (const node of el.childNodes) {
          if (node.nodeType === Node.TEXT_NODE) {
            const segmenter = new Intl.Segmenter([], { granularity: "word" });
            const segments = segmenter.segment(node.textContent ?? "");
            const spans = Array.from(segments).map(word => {
              const span = document.createElement("span");
              span.textContent = word.segment;
              return span;
            });
            setTimeout(() => {
              node.replaceWith(...spans);
            });
          } else if (node.nodeType === Node.ELEMENT_NODE) {
            if (!ignore(node as Element)) {
              spanify(node as Element, ignore);
            }
          }
        }
      }

      spanify(article, node =>
        (node.classList ?? []).contains("expressive-code")
      );

      let lastElement: Element | null;
      const cssClass = "text-green-500";
      article.addEventListener("mousemove", function (event) {
        const x = event.clientX;
        const y = event.clientY;
        const element = document.elementFromPoint(x, y);

        if (element?.tagName === "SPAN") {
          if (lastElement !== element) {
            element.classList.add(cssClass);
          }
        }

        lastElement = element;
      });
    })();
  </script>
</Layout>
